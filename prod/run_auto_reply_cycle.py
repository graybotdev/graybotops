import os
import glob
import sys
import json
import csv
import time
from datetime import datetime

# Setup imports
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from app.email_reader import read_recent_messages, save_to_json
from app.gpt_replies import build_prompt
from app.gmail_service import send_email
from app.ai_model_router import generate_response
from dotenv import load_dotenv

load_dotenv()

# Trigger vocab
TRIGGER_STATUSES = [
    "ready", "available", "loaded", "call", "tracking", "update", "in transit", "status",
    "delay", "delayed", "arrived", "en route", "checked in", "waiting", "detention", "layover",
    "invoice", "payment", "paid", "unpaid", "past due", "remit", "remittance", "accessorial",
    "lumper", "bol", "bill of lading", "pod", "proof of delivery", "receipt", "proof", "driver",
    "drop", "pickup", "pu", "del", "eta", "appointment", "check call", "where's the truck", "location"
]

LOG_FILE = os.path.join(os.path.dirname(__file__), "..", "logs", "email_log.csv")

def generate_reply(parsed_data):
    from app.firework_client import run_firework_model
    from app.openai_client import run_openai_model

    prompt = build_prompt(parsed_data)
    start = time.time()
    model_used = None

    # Try Firework first
    reply = run_firework_model(prompt)
    if reply:
        model_used = "Firework"
    else:
        print("‚ö†Ô∏è Firework failed. Trying OpenAI...")
        reply = run_openai_model(prompt)
        if reply:
            model_used = "OpenAI"

    duration = round(time.time() - start, 2)

    if reply:
        print(f"‚úÖ Reply generated by {model_used} in {duration}s")
        return reply, model_used
    else:
        print("üö® Failed to generate a reply.")
        return None, None

# Step 1: Read unread Gmail emails
messages = read_recent_messages()
save_to_json(messages)

# Step 2: Load latest parsed results
files = sorted(glob.glob("test/parsed_results_*.json"), key=os.path.getmtime, reverse=True)
FILENAME = files[0] if files else None

if not FILENAME:
    print("‚ùå No parsed results found.")
    exit()

with open(FILENAME, "r", encoding="utf-8") as f:
    parsed_messages = json.load(f)

# Step 3: Ensure log file exists
if not os.path.exists(LOG_FILE):
    with open(LOG_FILE, mode="w", newline="", encoding="utf-8") as log:
        writer = csv.writer(log)
        writer.writerow(["timestamp", "to_email", "subject", "model_used", "response"])

# Step 4: Process and respond to messages
for msg in parsed_messages:
    body = msg.get("body", "").lower()
    subject = msg.get("subject", "").lower()
    content = f"{subject} {body}"

    to_email = msg.get("from", "").strip()
    original_subject_line = msg.get("subject", "").strip()
    thread_id = msg.get("thread_id", None)

    if (
        not to_email or
        "mailer-daemon" in to_email.lower() or
        "noreply" in to_email.lower() or
        "delivery status notification" in subject
    ):
        print(f"‚ö†Ô∏è Skipping invalid or automated email: {to_email} | Subject: {original_subject_line}")
        continue

    if any(trigger in content for trigger in TRIGGER_STATUSES):
        reply, model_used = generate_reply(msg)

        if reply:
            # Clean up subject line
            base_subject = original_subject_line
            for tag in ["[SUCCESS]", "[FAILURE]", "[FW]", "[GPT]"]:
                if tag in base_subject:
                    base_subject = base_subject.replace(tag, "").strip()

            # Build updated subject
            model_tag = "[FW]" if model_used == "Firework" else "[GPT]"
            updated_subject = f"{base_subject} [SUCCESS] {model_tag}".strip()

            print(f"üì® Reply ready for {to_email} using {model_used}")
            print(reply)

            # ‚úÖ Send reply via Gmail
            send_email(to_email, updated_subject, reply, thread_id=thread_id)

            # üìÅ Log to CSV
            with open(LOG_FILE, mode="a", newline="", encoding="utf-8") as log:
                writer = csv.writer(log)
                writer.writerow([
                    datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
                    to_email,
                    updated_subject,
                    model_used,
                    reply
                ])
        else:
            # Clean up subject line for failure
            base_subject = original_subject_line
            for tag in ["[SUCCESS]", "[FAILURE]", "[FW]", "[GPT]"]:
                if tag in base_subject:
                    base_subject = base_subject.replace(tag, "").strip()

            updated_subject = f"{base_subject} [FAILURE]".strip()

            print(f"üö® No reply generated for {to_email} | Subject: {original_subject_line}")
            # No email sent on failure unless you want to customize further
    else:
        print(f"‚ùå No trigger match ‚Äî skipping: {original_subject_line}")
