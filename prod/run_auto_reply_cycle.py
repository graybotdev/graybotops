import os
import glob
import sys
import json
import csv
import time
import threading
from datetime import datetime
from dotenv import load_dotenv

# Flask app import
from download_log_server import app as flask_app

# App modules
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from app.email_reader import read_recent_messages, save_to_json
from app.gpt_replies import build_prompt
from app.gmail_service import send_email
from app.firework_client import run_firework_model
from app.openai_client import run_openai_model

load_dotenv()

# Ensure /logs/ exists
logs_dir = os.path.join(os.path.dirname(__file__), "..", "logs")
os.makedirs(logs_dir, exist_ok=True)

# CSV path
LOG_FILE = os.path.join(logs_dir, "email_log.csv")

# Trigger vocab
TRIGGER_STATUSES = [
    "ready", "available", "loaded", "call", "tracking", "update", "in transit", "status",
    "delay", "delayed", "arrived", "en route", "checked in", "waiting", "detention", "layover",
    "invoice", "payment", "paid", "unpaid", "past due", "remit", "remittance", "accessorial",
    "lumper", "bol", "bill of lading", "pod", "proof of delivery", "receipt", "proof", "driver",
    "drop", "pickup", "pu", "del", "eta", "appointment", "check call", "where's the truck", "location"
]

# Flask background runner
def run_flask_server():
    port = int(os.environ.get("PORT", 8080))
    flask_app.run(host="0.0.0.0", port=port)

# Start Flask server in background
flask_thread = threading.Thread(target=run_flask_server)
flask_thread.daemon = True
flask_thread.start()

def generate_reply(parsed_data):
    prompt = build_prompt(parsed_data)
    start = time.time()
    model_used = None

    reply = run_firework_model(prompt)
    if reply:
        model_used = "Firework"
    else:
        print("‚ö†Ô∏è Firework failed. Trying OpenAI...")
        reply = run_openai_model(prompt)
        if reply:
            model_used = "OpenAI"

    duration = round(time.time() - start, 2)

    if reply:
        print(f"‚úÖ Reply generated by {model_used} in {duration}s")
        return reply, model_used
    else:
        print("üö® Failed to generate a reply.")
        return None, None

if __name__ == "__main__":
    # Step 1: Read unread Gmail emails
    messages = read_recent_messages()
    save_to_json(messages)

    # Step 2: Load latest parsed results
    files = sorted(glob.glob("test/parsed_results_*.json"), key=os.path.getmtime, reverse=True)
    FILENAME = files[0] if files else None

    if not FILENAME:
        print("‚ùå No parsed results found.")
        exit()

    with open(FILENAME, "r", encoding="utf-8") as f:
        parsed_messages = json.load(f)

    # Step 3: Ensure CSV exists
    if not os.path.exists(LOG_FILE):
        with open(LOG_FILE, mode="w", newline="", encoding="utf-8") as log:
            writer = csv.writer(log)
            writer.writerow(["timestamp", "to_email", "subject", "model_used", "response"])

    # Step 4: Process messages
    for msg in parsed_messages:
        body = msg.get("body", "").lower()
        subject = msg.get("subject", "").lower()
        content = f"{subject} {body}"

        to_email = msg.get("from", "").strip()
        original_subject_line = msg.get("subject", "").strip()
        thread_id = msg.get("thread_id", None)

        print(f"üîé Checking email from: {to_email} | Subject: {original_subject_line}")

        if (
            not to_email or
            "mailer-daemon" in to_email.lower() or
            "noreply" in to_email.lower() or
            "delivery status notification" in subject
        ):
            print(f"‚ö†Ô∏è Skipping invalid or automated email: {to_email} | Subject: {original_subject_line}")
            continue

        if any(trigger in content for trigger in TRIGGER_STATUSES):
            print(f"‚úÖ Trigger matched for: {original_subject_line}")
            reply, model_used = generate_reply(msg)

            if reply:
                base_subject = original_subject_line
                for tag in ["[SUCCESS]", "[FAILURE]", "[FW]", "[GPT]"]:
                    base_subject = base_subject.replace(tag, "").strip()

                model_tag = "[FW]" if model_used == "Firework" else "[GPT]"
                updated_subject = f"{base_subject} [SUCCESS] {model_tag}".strip()

                print(f"üì® Reply ready for {to_email} using {model_used}")
                print(reply)

                send_email(to_email, updated_subject, reply, thread_id=thread_id)

                with open(LOG_FILE, mode="a", newline="", encoding="utf-8") as log:
                    writer = csv.writer(log)
                    writer.writerow([
                        datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
                        to_email,
                        updated_subject,
                        model_used,
                        reply
                    ])
            else:
                base_subject = original_subject_line
                for tag in ["[SUCCESS]", "[FAILURE]", "[FW]", "[GPT]"]:
                    base_subject = base_subject.replace(tag, "").strip()
                updated_subject = f"{base_subject} [FAILURE]".strip()
                print(f"üö® No reply generated for {to_email} | Subject: {original_subject_line}")
        else:
            print(f"‚ùå No trigger match ‚Äî skipping: {original_subject_line}")

    # Keep container alive for Flask dashboard
    print("‚úÖ Reply cycle complete. Flask server is running.")
    while True:
        time.sleep(10)
